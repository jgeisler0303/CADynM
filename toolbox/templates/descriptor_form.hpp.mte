{{ fprintf("/* Multibody system: %s */", temp_data.Name); }}

#include <string>
#include <map>
#include <fstream>
#include <iostream>
#include <stdlib.h>
#include <chrono>
#include <cstdio>
#include <ctime>
#include <array>

typedef double real_type;

#include "{{ fprintf('%s_param.hpp', temp_data.Name); }}"


class {{ fprintf("%s", temp_data.Name); }} {
public:
    typedef Eigen::Matrix<real_type, {{ fprintf('%d', temp_data.getNumDOF); }}, 1> VecQ;
    typedef Eigen::Matrix<real_type, {{ fprintf('%d', temp_data.getNumIn); }}, 1> VecI;
    typedef Eigen::Matrix<real_type, {{ fprintf('%d', temp_data.getNumOut); }}, 1> VecO;
    typedef Eigen::Matrix<real_type, {{ fprintf('%d, %d', temp_data.getNumDOF, temp_data.getNumDOF); }}> MatQ;
    typedef Eigen::Matrix<real_type, {{ fprintf('%d, %d', temp_data.getNumDOF, temp_data.getNumIn); }}> MatQI;
    typedef Eigen::Matrix<real_type, {{ fprintf('%d, %d', temp_data.getNumOut, temp_data.getNumDOF); }}> MatOQ;
    typedef Eigen::Matrix<real_type, {{ fprintf('%d, %d', temp_data.getNumOut, 2*temp_data.getNumDOF+temp_data.getNumIn); }}> MatCD;
    typedef Eigen::Matrix<real_type, {{ fprintf('%d, %d', 2*temp_data.getNumDOF, 2*temp_data.getNumDOF); }}> Mat2Q;
    typedef Eigen::Matrix<real_type, {{ fprintf('%d, %d', 2*temp_data.getNumDOF, 2*temp_data.getNumDOF+temp_data.getNumIn); }}> MatS;
    
    {{ fprintf("%s", temp_data.Name); }}();
        
    void precalcConsts();
    void calcMf();
    void calcJacobian();
    void calcB();
    void calcCDF();
    void calcOut();
{{ 
if temp_data.getNumExternals() > 0
    fprintf('    void calculateExternal();\n');
    fprintf('    void calculateExternalWithDeriv();\n');
end
}}
    
    {{ fprintf('%sParameters param;', temp_data.Name); }}
    
// private:
    static constexpr int nbrdof = {{ fprintf('%d', temp_data.getNumDOF); }};
    static constexpr int nbrout = {{ fprintf('%d', temp_data.getNumOut); }};
    static constexpr int nbrin = {{ fprintf('%d', temp_data.getNumIn); }};
    std::array<std::string, nbrdof> state_name;
    std::array<std::string, nbrin> in_name;
    VecQ f;
    MatQ M;
    MatOQ F;
    MatQI B;
    MatQ K;
    MatQ C;
    MatCD CD;
    VecQ q, qd, qdd;
    VecI u;
    VecO y;

{{ 
% Inputs struct
fprintf('    struct inputs_t {\n');
fprintf('    public:\n');
fprintf('        inputs_t(');
for i = 1:temp_data.getNumIn()
    fprintf('real_type &%s', temp_data.getInName(i));
    if i ~= temp_data.getNumIn()
        fprintf(', ');
    end
end
fprintf(') : ');
for i = 1:temp_data.getNumIn()
    fprintf('%s(%s)', temp_data.getInName(i), temp_data.getInName(i));
    if i ~= temp_data.getNumIn()
        fprintf(', ');
    end
end
fprintf(' {}\n\n');
for i = 1:temp_data.getNumIn()
    fprintf('        real_type  &%s;\n', temp_data.getInName(i));
end
fprintf('    } inputs;\n\n');
}}
{{
% Outputs struct
fprintf('    struct outputs_t {\n');
fprintf('    public:\n');
fprintf('        outputs_t(');
for i = 1:temp_data.getNumOut()
    fprintf('real_type &%s', temp_data.getOutName(i));
    if i ~= temp_data.getNumOut()
        fprintf(', ');
    end
end
fprintf(') : ');
for i = 1:temp_data.getNumOut()
    fprintf('%s(%s)', temp_data.getOutName(i), temp_data.getOutName(i));
    if i ~= temp_data.getNumOut()
        fprintf(', ');
    end
end
fprintf(' {}\n\n');
for i = 1:temp_data.getNumOut()
    fprintf('        real_type  &%s;\n', temp_data.getOutName(i));
end
fprintf('    } outputs;\n\n');
}}
{{
fprintf('    struct states_t {\n');
fprintf('    public:\n');
fprintf('        states_t(');
for i = 1:temp_data.getNumDOF()
    if i ~= 1
        fprintf(', ');
    end
    fprintf('real_type &%s, real_type &%s, real_type &%s', temp_data.getQName(i), temp_data.getQdName(i), temp_data.getQddName(i));
end
for i = 1:temp_data.getNumAux()
    if temp_data.getNumDOF()>0
        fprintf(', ');
    end
    fprintf('real_type &%s, real_type &%s, real_type &%s', temp_data.getAuxName(i, 0), temp_data.getAuxName(i, 1), temp_data.getAuxName(i, 2));
end
fprintf(') : ');
for i = 1:temp_data.getNumDOF()
    if i ~= 1
        fprintf(', ');
    end
    fprintf('%s(%s), %s(%s), %s(%s)', temp_data.getQName(i), temp_data.getQName(i), temp_data.getQdName(i), temp_data.getQdName(i), temp_data.getQddName(i), temp_data.getQddName(i));
end
for i = 1:temp_data.getNumAux()
    if temp_data.getNumDOF()>0
        fprintf(', ');
    end
    fprintf('%s(%s), %s(%s), %s(%s)', temp_data.getAuxName(i), temp_data.getAuxName(i, 0), temp_data.getAuxName(i, 1), temp_data.getAuxName(i, 1), temp_data.getAuxName(i, 2), temp_data.getAuxName(i, 2));
end
fprintf(' {}\n\n');
for i = 1:temp_data.getNumDOF()
    fprintf('        real_type  &%s;\n', temp_data.getQName(i));
    fprintf('        real_type  &%s;\n', temp_data.getQdName(i));
    fprintf('        real_type  &%s;\n', temp_data.getQddName(i));
end
for i = 1:temp_data.getNumAux()
    fprintf('        real_type  &%s;\n', temp_data.getAuxName(i, 0));
    fprintf('        real_type  &%s;\n', temp_data.getAuxName(i, 1));
    fprintf('        real_type  &%s;\n', temp_data.getAuxName(i, 2));
end
fprintf('    } states;\n\n');

fprintf('    typedef struct {\n');
for i = 1:temp_data.getNumDOF()
    fprintf('        int %s;\n', temp_data.getQName(i));
end
for i = 1:temp_data.getNumAux()
    fprintf('        int %s;\n', temp_data.getAuxName(i, 0));
end
fprintf('    } states_idx_type;\n\n');

fprintf('    typedef struct {\n');
for i = 1:temp_data.getNumIn()
    fprintf('        int %s;\n', temp_data.getInName(i));
end
fprintf('    } inputs_idx_type;\n\n');

fprintf('    typedef struct {\n');
for i = 1:temp_data.getNumOut()
    fprintf('        int %s;\n', temp_data.getOutName(i));
end
fprintf('    } outputs_idx_type;\n');
}}

    static const states_idx_type states_idx;
    static const inputs_idx_type inputs_idx;
    static const outputs_idx_type outputs_idx;
    
{{ 
for i = 1:temp_data.getNumExternals()
    fprintf('\n    real_type %s;\n', temp_data.getExternalName(i));
end
for i = 1:temp_data.getNumExternals()
    d = temp_data.getExternalDerivs(i);
    for j = 1:length(d)
        fprintf('    real_type %s;\n', d{j});
    end
end
}}};

{{ 
fprintf('const %s::states_idx_type %s::states_idx= {', temp_data.Name, temp_data.Name);
for i = 1:temp_data.getNumDOF()
    if i ~= 1
        fprintf(', ');
    end
    fprintf('%d', i-1);
end
for i = 1:temp_data.getNumAux()
    if temp_data.getNumDOF() ~= 0
        fprintf(', ');
    end
    fprintf('%d', i-1+temp_data.getNumDOF());
end
fprintf('};\n');

fprintf('const %s::inputs_idx_type %s::inputs_idx= {', temp_data.Name, temp_data.Name);
for i = 1:temp_data.getNumIn()
    fprintf('%d', i-1);
    if i ~= temp_data.getNumIn()
        fprintf(', ');
    end
end
fprintf('};\n');

fprintf('const %s::outputs_idx_type %s::outputs_idx= {', temp_data.Name, temp_data.Name);
for i = 1:temp_data.getNumOut()
    fprintf('%d', i-1);
    if i ~= temp_data.getNumOut()
        fprintf(', ');
    end
end
fprintf('};\n');
}}

{{ fprintf("%s", temp_data.Name); }}::{{ fprintf("%s", temp_data.Name); }}() : 
    param(),
{{fprintf('    inputs(');
for i = 1:temp_data.getNumIn()
    fprintf('u.data()[%d]', i-1);
    if i ~= temp_data.getNumIn()
        fprintf(', ');
    end
end
fprintf('),\n');

fprintf('    outputs(');
for i = 1:temp_data.getNumOut()
    fprintf('y.data()[%d]', i-1);
    if i ~= temp_data.getNumOut()
        fprintf(', ');
    end
end

fprintf('),\n    states(');
for i = 1:temp_data.getNumDOF()+temp_data.getNumAux()
    if i ~= 1
        fprintf(', ');
    end
    fprintf('q.data()[%d], qd.data()[%d], qdd.data()[%d]', i-1, i-1, i-1);
end
fprintf(')\n');
}}{
{{ 
    for i = 1:temp_data.getNumIn()
        i_ = i - 1;
        fprintf('    in_name[%d] = "%s";\n', i_, temp_data.getInName(i));
    end
}}
{{
    i_ = 0;
    for i = 1:temp_data.getNumDOF()
        fprintf('    state_name[%d] = "%s";\n', i_, temp_data.getQName(i));
        i_ = i_ + 1;
    end    
    for i = 1:temp_data.getNumAux()
        fprintf('    state_name[%d] = "%s";\n', i_, temp_data.getAuxName(i));
        i_ = i_ + 1;
    end    
}}}

void {{ fprintf("%s", temp_data.Name); }}::precalcConsts() {
{{
    const_selector = @(e)temp_data.isConstant(e, 'cpp');
    
    M = temp_data.replaceVars(temp_data.getM(true), 'cpp');
    printAssignC(4, 'M', M, 'matrix', const_selector)
    fprintf("\n");
    
    C = temp_data.replaceVars(temp_data.getC(true), 'cpp');
    printAssignC(4, 'C', C, 'matrix', const_selector)
    fprintf("\n");

    K = temp_data.replaceVars(temp_data.getK(true), 'cpp');
    printAssignC(4, 'K', K, 'matrix', const_selector)
    fprintf("\n");

    B = temp_data.replaceVars(temp_data.getB(true), 'cpp');
    printAssignC(4, 'B', B, 'matrix', const_selector)
    fprintf("\n");

    CD = temp_data.replaceVars(temp_data.getCD(true), 'cpp');
    printAssignC(4, 'CD', CD, 'matrix', const_selector)
    fprintf("\n");
    
    F = temp_data.replaceVars(temp_data.getF(true), 'cpp');
    printAssignC(4, 'F', F, 'matrix', const_selector)
}}}

void {{ fprintf("%s", temp_data.Name); }}::calcMf() {
{{ 
    if temp_data.getNumExternals() > 0
        fprintf("    // TODO: check if it is possible that externals enter teh mass matrix\n");        
        fprintf("    calculateExternal();\n");
    end
}}
    {
{{
    not_const_selector = @(e)~temp_data.isConstant(e, 'cpp');

    eom =  temp_data.getEOM(true);
    [eom, vars] = temp_data.replaceVars(eom, 'cpp');
    M  = temp_data.replaceVars(temp_data.getM(true), 'cpp');
    f_ = M*vars.qdd - eom;

    n_dof_aux = temp_data.getNumDOF()+temp_data.getNumAux();
    for i = 1:n_dof_aux
        for j = 1:n_dof_aux
            if ~not_const_selector(M(i, j))
                M(i, j) = 0; % constant elements dont need to be optimized
            end
        end
    end

    [opt, tnames, tvalues] = temp_data.optimize(f_, M);
    for i = 1:length(tnames)
        printAssignC('        real_type ', char(tnames(i)), tvalues(i), 'scalar')
    end
    if ~isempty(tnames), fprintf("\n"); end
    
    n = printAssignC(8, 'M', opt{2}, 'matrix', not_const_selector);
    if n>0, fprintf("\n"); end
        
    printAssignC(8, 'f', opt{1}, 'vector_par')
}}    }
}

void {{ fprintf("%s", temp_data.Name); }}::calcJacobian() {
{{ 
    if temp_data.getNumExternals() > 0
        fprintf("    calculateExternalWithDeriv();\n");
    end
}}
    {
{{ 
    not_const_selector = @(e)~temp_data.isConstant(e, 'cpp');
    
    C = temp_data.replaceVars(temp_data.getC(true), 'cpp');
    K = temp_data.replaceVars(temp_data.getK(true), 'cpp');
    
    n_dof_aux = temp_data.getNumDOF()+temp_data.getNumAux();
    for i = 1:n_dof_aux
        for j = 1:n_dof_aux
            if ~not_const_selector(C(i, j))
                C(i, j) = 0; % constant elements dont need to be optimized
            end
            if ~not_const_selector(K(i, j))
                K(i, j) = 0; % constant elements dont need to be optimized
            end
        end
    end

    [opt, tnames, tvalues] = temp_data.optimize(C, K);
    for i = 1:length(tnames)
        printAssignC('        real_type ', char(tnames(i)), tvalues(i), 'scalar')
    end
    if ~isempty(tnames), fprintf("\n"); end
        
    n = printAssignC(8, 'C', opt{1}, 'matrix', not_const_selector);
    if n>0, fprintf("\n"); end
    n = printAssignC(8, 'K', opt{2}, 'matrix', not_const_selector);
}}    }
}

void {{ fprintf("%s", temp_data.Name); }}::calcB() {
{{ 
    not_const_selector = @(e)~temp_data.isConstant(e, 'cpp');
    
    B = temp_data.replaceVars(temp_data.getB(true), 'cpp');
    for i = 1:(temp_data.getNumDOF()+temp_data.getNumAux())
        for j = 1:temp_data.getNumIn()
            if ~not_const_selector(B(i, j))
                B(i, j) = 0; % constant elements dont need to be optimized
            end
        end
    end

    [opt, tnames, tvalues] = temp_data.optimize(B);
    for i = 1:length(tnames)
        printAssignC('        real_type ', char(tnames(i)), tvalues(i), 'scalar')
    end
    if ~isempty(tnames), fprintf("\n"); end
    
    printAssignC(4, 'B', opt{1}, 'matrix', not_const_selector)
}}}

void {{ fprintf("%s", temp_data.Name); }}::calcCDF() {
{{ 
    not_const_selector = @(e)~temp_data.isConstant(e, 'cpp');
    
    y = temp_data.replaceVars(struct2array(temp_data.outputs), 'cpp').';
    CD = temp_data.replaceVars(temp_data.getCD(true), 'cpp');
    F = temp_data.replaceVars(temp_data.getF(true), 'cpp');
    
    for i = 1:temp_data.getNumOut()
        for j = 1:(2*temp_data.getNumDOF()+2*temp_data.getNumAux()+temp_data.getNumIn())
            if ~not_const_selector(CD(i, j))
                CD(i, j) = 0; % constant elements dont need to be optimized
            end
        end
        for j = 1:(temp_data.getNumDOF()+temp_data.getNumAux())
            if ~not_const_selector(F(i, j))
                F(i, j) = 0; % constant elements dont need to be optimized
            end
        end
    end

    [opt, tnames, tvalues] = temp_data.optimize(y, CD, F);
    for i = 1:length(tnames)
        printAssignC('        real_type ', char(tnames(i)), tvalues(i), 'scalar')
    end
    if ~isempty(tnames), fprintf("\n"); end
    
    n = printAssignC(4, 'y', opt{1}, 'vector_par');
    if n>0, fprintf("\n"); end
    n = printAssignC(4, 'CD', opt{2}, 'matrix', not_const_selector);
    if n>0, fprintf("\n"); end
    printAssignC(4, 'F', opt{3}, 'matrix', not_const_selector)
}}}

void {{ fprintf("%s", temp_data.Name); }}::calcOut() {
{{ 
    y = temp_data.replaceVars(struct2array(temp_data.outputs), 'cpp');
    
    [opt, tnames, tvalues] = temp_data.optimize(y);
    for i = 1:length(tnames)
        printAssignC('        real_type ', char(tnames(i)), tvalues(i), 'scalar')
    end
    if ~isempty(tnames), fprintf("\n"); end
    
    printAssignC(4, 'y', opt{1}, 'vector_par')
}}}

{{ 
% Optional: external headers
if temp_data.getNumExternals() > 0
    fprintf('#include "%s_Externals.hpp"\n', temp_data.Name);
end
}}
